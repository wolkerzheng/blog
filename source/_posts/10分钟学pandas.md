---
title: 10分钟学pandas
date: 2017-04-10 18:48:40
tags: python
---
主要学习pandas使用
原文：http://pandas.pydata.org/pandas-docs/stable/10min.html
### 导入相关包
```
    import pandas as pd
    import numpy as np
    import matplotlib.pylot as plt
```
<!--more-->
读写csv文件

  写入
      df.to_csv(filename)
  读取
      pd.read_csv(filename,header=0) #保留列属性，header=None不读列属性
缺失值处理

  去掉包含缺失值的行
      df.dropna(how=’any’)
  对缺失值进行填充
      df.fillna(value=5)
  选择行或列

      df.iloc[3] #第四行
      df.iloc[:,3] #第四列
      df.iloc[3:5,0:2] #第四到六行，第一到三列
      df.iloc[[4,5,6],[0,1,2]] #第四到六行，第一到三列

      df[] #这是对行进行切片

统计

    df.describe() #描述
    df.head() #头五行
    df.tail() #尾五行
    df.T #转置
    df.sort(columns=’B’)# 对轴进行排序
    df.mean() #对每列求均值 通过axis=0/1 确定行列
映射

    df.apply(function) #通过自定义函数，应用于df中
    例如：df.apply(lambda x:x.max()-x.min()) #求得每列最大减最小，通过axis=1 进行行操作
合并

    pd.concat(list) #list各元素为各个DateFrame
    例如 pieces = [df[:3],df[3:6],df[6]]；pd.concat(pieces)

### 创建对象
1.通过传递一个List对象来创建一个Series
```
    s = pd.Series([1,3,5,np.nan,6,8])
    Out[5]:
    0    1.0
    1    3.0
    2    5.0
    3    NaN
    4    6.0
    5    8.0
    dtype: float64
```
2.传入一个numpy数组创建一个DataFrame
```
    dates = pd.date_range('20130101', periods=6)
    Out[7]:
    DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',
                   '2013-01-05', '2013-01-06'],
                  dtype='datetime64[ns]', freq='D')
    df = pd.DataFrame(np.random.randn(6,4), index=dates,columns=list('ABCD'))
    Out[9]:
                       A         B         C         D
    2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860
    2013-01-05 -0.424972  0.567020  0.276232 -1.087401
    2013-01-06 -0.673690  0.113648 -1.478427  0.524988

```
3.传入一个字典对象，创建DataFrame
```
    df2 = pd.DataFrame({'A':1,'B':pd.Timestamp('20130102'),
          'C' : pd.Series(1,index=list(range(4)),dtype='float32'),
            'D' : np.array([3] * 4,dtype='int32'),
            'E' : pd.Categorical(["test","train","test","train"]),
            'F' : 'foo'})

    Out[11]:
           A          B    C  D      E    F
      0  1.0 2013-01-02  1.0  3   test  foo
      1  1.0 2013-01-02  1.0  3  train  foo
      2  1.0 2013-01-02  1.0  3   test  foo
      3  1.0 2013-01-02  1.0  3  train  foo
    df2.dtypes
    Out:
    A           float64
    B    datetime64[ns]
    C           float32
    D             int32
    E          category
    F            object
    dtype: object
```
看Frame的头和尾行;
df.head() #头五行
df.tail() #尾五行
```
    df.head()
    Out[14]:
                       A         B         C         D
    2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860
    2013-01-05 -0.424972  0.567020  0.276232 -1.087401
    df.tail(3)
    Out[15]:
                       A         B         C         D
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860
    2013-01-05 -0.424972  0.567020  0.276232 -1.087401
    2013-01-06 -0.673690  0.113648 -1.478427  0.524988
```
展示索引，列，和数据
```
    df.index
    Out[16]:
    DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',
                   '2013-01-05', '2013-01-06'],
                  dtype='datetime64[ns]', freq='D')
    df.columns
    Out[17]: Index([u'A', u'B', u'C', u'D'], dtype='object')
    df.values
    Out[18]:
    array([[ 0.4691, -0.2829, -1.5091, -1.1356],
           [ 1.2121, -0.1732,  0.1192, -1.0442],
           [-0.8618, -2.1046, -0.4949,  1.0718],
           [ 0.7216, -0.7068, -1.0396,  0.2719],
           [-0.425 ,  0.567 ,  0.2762, -1.0874],
           [-0.6737,  0.1136, -1.4784,  0.525 ]])
```
描述数据的统计结果
```
    df.describe()
    Out[19]:
                  A         B         C         D
    count  6.000000  6.000000  6.000000  6.000000
    mean   0.073711 -0.431125 -0.687758 -0.233103
    std    0.843157  0.922818  0.779887  0.973118
    min   -0.861849 -2.104569 -1.509059 -1.135632
    25%   -0.611510 -0.600794 -1.368714 -1.076610
    50%    0.022070 -0.228039 -0.767252 -0.386188
    75%    0.658444  0.041933 -0.034326  0.461706
    max    1.212112  0.567020  0.276232  1.071804
```
数据转置
```
    df.T
    Out[20]:
       2013-01-01  2013-01-02  2013-01-03  2013-01-04  2013-01-05  2013-01-06
    A    0.469112    1.212112   -0.861849    0.721555   -0.424972   -0.673690
    B   -0.282863   -0.173215   -2.104569   -0.706771    0.567020    0.113648
    C   -1.509059    0.119209   -0.494929   -1.039575    0.276232   -1.478427
    D   -1.135632   -1.044236    1.071804    0.271860   -1.087401    0.524988
```
按axis排序
```
    df.sort_index(axis=1,ascending=False)
    Out[21]:
                       D         C         B         A
    2013-01-01 -1.135632 -1.509059 -0.282863  0.469112
    2013-01-02 -1.044236  0.119209 -0.173215  1.212112
    2013-01-03  1.071804 -0.494929 -2.104569 -0.861849
    2013-01-04  0.271860 -1.039575 -0.706771  0.721555
    2013-01-05 -1.087401  0.276232  0.567020 -0.424972
    2013-01-06  0.524988 -1.478427  0.113648 -0.673690
```
按指定值排序
```
    df.sort_values(by='B')
    Out[22]:
                       A         B         C         D
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860
    2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-06 -0.673690  0.113648 -1.478427  0.524988
    2013-01-05 -0.424972  0.567020  0.276232 -1.087401
```
### 选择操作:.at, .iat, .loc, .iloc 和 .ix等
选择一列，生成一个Series,
```
    df['A']  #等价于df.A
    Out[23]:
    2013-01-01    0.469112
    2013-01-02    1.212112
    2013-01-03   -0.861849
    2013-01-04    0.721555
    2013-01-05   -0.424972
    2013-01-06   -0.673690
    Freq: D, Name: A, dtype: float64

    df[0:3]
    Out[24]:
                       A         B         C         D
    2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804

    df['20130102':'20130104']
    Out[25]:
                       A         B         C         D
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860
```
通过标签选择
```
    df.loc[dates[0]]
    Out[26]:
    A    0.469112
    B   -0.282863
    C   -1.509059
    D   -1.135632
    Name: 2013-01-01 00:00:00, dtype: float64
```
通过标签选择多列
```
    df.loc[:,['A','B']]
    Out[27]:
                       A         B
    2013-01-01  0.469112 -0.282863
    2013-01-02  1.212112 -0.173215
    2013-01-03 -0.861849 -2.104569
    2013-01-04  0.721555 -0.706771
    2013-01-05 -0.424972  0.567020
    2013-01-06 -0.673690  0.113648

    df.loc['20130102':'20130104',['A','B']]
    Out[28]:
                       A         B
    2013-01-02  1.212112 -0.173215
    2013-01-03 -0.861849 -2.104569
    2013-01-04  0.721555 -0.706771

     df.loc['20130102',['A','B']]
     Out:
      A    1.212112
      B   -0.173215
      Name: 2013-01-02 00:00:00, dtype: float64

    df.loc[dates[0],'A']
    Out[30]: 0.46911229990718628

    df.at[dates[0],'A']
    Out[31]: 0.46911229990718628
```
### 按位置选择
通过传入的整数值位置获取
```
    df.iloc[3]
    Out[32]:
    A    0.721555
    B   -0.706771
    C   -1.039575
    D    0.271860
    Name: 2013-01-04 00:00:00, dtype: float64

    df.iloc[3:5,0:2]
    Out[34]:
                       A         C
    2013-01-02  1.212112  0.119209
    2013-01-03 -0.861849 -0.494929
    2013-01-05 -0.424972  0.276232

    df.iloc[1:3,:]
    Out[35]:
                       A         B         C         D
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804

    df.iloc[:,1:3]
    Out[35]:
                       A         B         C         D
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804

    df.iloc[1,1]
    Out[37]: -0.17321464905330858

    df.iat[1,1]
    Out[38]: -0.17321464905330858
```
布尔索引
```
    In [39]: df[df.A > 0]
    Out[39]:
                   A         B         C         D
    2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860

    df[df>0]
    Out[40]:
                       A         B         C         D
    2013-01-01  0.469112       NaN       NaN       NaN
    2013-01-02  1.212112       NaN  0.119209       NaN
    2013-01-03       NaN       NaN       NaN  1.071804
    2013-01-04  0.721555       NaN       NaN  0.271860
    2013-01-05       NaN  0.567020  0.276232       NaN
    2013-01-06       NaN  0.113648       NaN  0.524988
```
使用IsIn()来过滤
```
    df2 = df.copy()
    df2['E'] = ['one', 'one','two','three','four','three']
    In [43]: df2
    Out[43]:
                       A         B         C         D      E
    2013-01-01  0.469112 -0.282863 -1.509059 -1.135632    one
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236    one
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804    two
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860  three
    2013-01-05 -0.424972  0.567020  0.276232 -1.087401   four
    2013-01-06 -0.673690  0.113648 -1.478427  0.524988  three

    df2[df2['E'].isin(['two','four'])]
    Out[44]:
                       A         B         C         D     E
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804   two
    2013-01-05 -0.424972  0.567020  0.276232 -1.087401  four
```
### 设置
设置一个新列将自动按索引排列数据
```
    s1 = pd.Series([1,2,3,4,5,6], index=pd.date_range('20130102', periods=6))
    Out[46]:
    2013-01-02    1
    2013-01-03    2
    2013-01-04    3
    2013-01-05    4
    2013-01-06    5
    2013-01-07    6
    Freq: D, dtype: int64

    df['F'] = s1
    df.at[dates[0],'A'] = 0
    df.iat[0,1] = 0
    df.loc[:,'D'] = np.array([5] * len(df))

    In [51]: df
    Out[51]:
                       A         B         C  D    F
    2013-01-01  0.000000  0.000000 -1.509059  5  NaN
    2013-01-02  1.212112 -0.173215  0.119209  5  1.0
    2013-01-03 -0.861849 -2.104569 -0.494929  5  2.0
    2013-01-04  0.721555 -0.706771 -1.039575  5  3.0
    2013-01-05 -0.424972  0.567020  0.276232  5  4.0
    2013-01-06 -0.673690  0.113648 -1.478427  5  5.0

    df2 = df.copy()
    df2[df2 > 0] = -df2
    Out[54]:
                       A         B         C  D    F
    2013-01-01  0.000000  0.000000 -1.509059 -5  NaN
    2013-01-02 -1.212112 -0.173215 -0.119209 -5 -1.0
    2013-01-03 -0.861849 -2.104569 -0.494929 -5 -2.0
    2013-01-04 -0.721555 -0.706771 -1.039575 -5 -3.0
    2013-01-05 -0.424972 -0.567020 -0.276232 -5 -4.0
    2013-01-06 -0.673690 -0.113648 -1.478427 -5 -5.0
```
### 处理缺失值
pandas主要是使用np.nan来处理缺失数据。默认情况下不包括在计算中。
reindex操作可以change/add/delete指定列的索引。
```
    df1 = df.reindex(index=dates[0:4], columns=list(df.columns) + ['E'])
    df1.loc[dates[0]:dates[1],'E'] = 1
    Out[57]:
                       A         B         C  D    F    E
    2013-01-01  0.000000  0.000000 -1.509059  5  NaN  1.0
    2013-01-02  1.212112 -0.173215  0.119209  5  1.0  1.0
    2013-01-03 -0.861849 -2.104569 -0.494929  5  2.0  NaN
    2013-01-04  0.721555 -0.706771 -1.039575  5  3.0  NaN
```
删除any有缺失值的行
```
    df1.dropna(how='any')
    Out[58]:
                       A         B         C  D    F    E
    2013-01-02  1.212112 -0.173215  0.119209  5  1.0  1.0    
```
填充缺失值
```
    df1.fillna(value=5)
    Out[59]:
                       A         B         C  D    F    E
    2013-01-01  0.000000  0.000000 -1.509059  5  5.0  1.0
    2013-01-02  1.212112 -0.173215  0.119209  5  1.0  1.0
    2013-01-03 -0.861849 -2.104569 -0.494929  5  2.0  5.0
    2013-01-04  0.721555 -0.706771 -1.039575  5  3.0  5.0    
```
获取是否有值为nan
```
    pd.isnull(df1)
    Out[60]:
                    A      B      C      D      F      E
    2013-01-01  False  False  False  False   True  False
    2013-01-02  False  False  False  False  False  False
    2013-01-03  False  False  False  False  False   True
    2013-01-04  False  False  False  False  False   True    
```
### 操作
统计
操作一般不包括缺失数据。
执行描述性统计
```
    df.mean()
    Out[61]:
    A   -0.004474
    B   -0.383981
    C   -0.687758
    D    5.000000
    F    3.000000
    dtype: float64

    df.mean(1)
    Out[62]:
    2013-01-01    0.872735
    2013-01-02    1.431621
    2013-01-03    0.707731
    2013-01-04    1.395042
    2013-01-05    1.883656
    2013-01-06    1.592306
    Freq: D, dtype: float64    
```
操作具有不同维度和需要对齐的对象。 pandas会沿着指定的维度自动广播。
```
    s = pd.Series([1,3,5,np.nan,6,8], index=dates).shift(2)
    In [64]: s
    Out[64]:
    2013-01-01    NaN
    2013-01-02    NaN
    2013-01-03    1.0
    2013-01-04    3.0
    2013-01-05    5.0
    2013-01-06    NaN
    Freq: D, dtype: float64   

    In [65]: df.sub(s, axis='index')
    Out[65]:
                       A         B         C    D    F
    2013-01-01       NaN       NaN       NaN  NaN  NaN
    2013-01-02       NaN       NaN       NaN  NaN  NaN
    2013-01-03 -1.861849 -3.104569 -1.494929  4.0  1.0
    2013-01-04 -2.278445 -3.706771 -4.039575  2.0  0.0
    2013-01-05 -5.424972 -4.432980 -4.723768  0.0 -1.0
    2013-01-06       NaN       NaN       NaN  NaN  NaN
```
Apply
函数操作到数据上
```
    df.apply(np.cumsum)
    Out[66]:
                       A         B         C   D     F
    2013-01-01  0.000000  0.000000 -1.509059   5   NaN
    2013-01-02  1.212112 -0.173215 -1.389850  10   1.0
    2013-01-03  0.350263 -2.277784 -1.884779  15   3.0
    2013-01-04  1.071818 -2.984555 -2.924354  20   6.0
    2013-01-05  0.646846 -2.417535 -2.648122  25  10.0
    2013-01-06 -0.026844 -2.303886 -4.126549  30  15.0    

    df.apply(lambda x: x.max() - x.min())
    Out[67]:
    A    2.073961
    B    2.671590
    C    1.785291
    D    0.000000
    F    4.000000
    dtype: float64
```
Histogramming
```
    s = pd.Series(np.random.randint(0, 7, size=10))
    Out[69]:
    0    4
    1    2
    2    1
    3    2
    4    6
    5    4
    6    4
    7    6
    8    4
    9    4
    dtype: int64

    s.value_counts()
    Out[70]:
    4    5
    6    2
    2    2
    1    1
    dtype: int64
```
String Methods
Series在str属性中配置了一组字符串处理方法，可以方便地对数组的每个元素进行操作，如下面的代码片段所示。请注意，str中的模式匹配通常默认使用正则表达式（在某些情况下，始终使用它们）。
```
    s = pd.Series(['A', 'B', 'C', 'Aaba', 'Baca', np.nan, 'CABA', 'dog','cat'])
    s.str.lower()
    Out[72]:
    0       a
    1       b
    2       c
    3    aaba
    4    baca
    5     NaN
    6    caba
    7     dog
    8     cat
    dtype: object
```
### 合并
concat
```
    df = pd.DataFrame(np.random.randn(10,4))  #10条数据，4列
    df
    Out[74]:
              0         1         2         3
    0 -0.548702  1.467327 -1.015962 -0.483075
    1  1.637550 -1.217659 -0.291519 -1.745505
    2 -0.263952  0.991460 -0.919069  0.266046
    3 -0.709661  1.669052  1.037882 -1.705775
    4 -0.919854 -0.042379  1.247642 -0.009920
    5  0.290213  0.495767  0.362949  1.548106
    6 -1.131345 -0.089329  0.337863 -0.945867
    7 -0.932132  1.956030  0.017587 -0.016692
    8 -0.575247  0.254161 -1.143704  0.215897
    9  1.193555 -0.077118 -0.408530 -0.862495

    pieces = [df[:3],df[3:7],df[7:]]  #切片
    pd.concat(pieces)
    Out[76]:
              0         1         2         3
    0 -0.548702  1.467327 -1.015962 -0.483075
    1  1.637550 -1.217659 -0.291519 -1.745505
    2 -0.263952  0.991460 -0.919069  0.266046
    3 -0.709661  1.669052  1.037882 -1.705775
    4 -0.919854 -0.042379  1.247642 -0.009920
    5  0.290213  0.495767  0.362949  1.548106
    6 -1.131345 -0.089329  0.337863 -0.945867
    7 -0.932132  1.956030  0.017587 -0.016692
    8 -0.575247  0.254161 -1.143704  0.215897
    9  1.193555 -0.077118 -0.408530 -0.862495
```
join
```
    left = pd.DataFrame({'key': ['foo', 'foo'], 'lval': [1, 2]})
    right = pd.DataFrame({'key': ['foo', 'foo'], 'rval': [4, 5]})

    Out[79]: left
       key  lval
    0  foo     1
    1  foo     2

    Out[80]: right
       key  rval
    0  foo     4
    1  foo     5

    pd.merge(left, right, on='key')
    Out[81]:
       key  lval  rval
    0  foo     1     4
    1  foo     1     5
    2  foo     2     4
    3  foo     2     5
```
append
```
    df = pd.DataFrame(np.random.randn(8, 4), columns=['A','B','C','D'])
    Out[88]:
              A         B         C         D
    0  1.346061  1.511763  1.627081 -0.990582
    1 -0.441652  1.211526  0.268520  0.024580
    2 -1.577585  0.396823 -0.105381 -0.532532
    3  1.453749  1.208843 -0.080952 -0.264610
    4 -0.727965 -0.589346  0.339969 -0.693205
    5 -0.339355  0.593616  0.884345  1.591431
    6  0.141809  0.220390  0.435589  0.192451
    7 -0.096701  0.803351  1.715071 -0.708758

    s = df.iloc[3]
    df.append(s, ignore_index=True)
    Out[90]:
              A         B         C         D
    0  1.346061  1.511763  1.627081 -0.990582
    1 -0.441652  1.211526  0.268520  0.024580
    2 -1.577585  0.396823 -0.105381 -0.532532
    3  1.453749  1.208843 -0.080952 -0.264610
    4 -0.727965 -0.589346  0.339969 -0.693205
    5 -0.339355  0.593616  0.884345  1.591431
    6  0.141809  0.220390  0.435589  0.192451
    7 -0.096701  0.803351  1.715071 -0.708758
    8  1.453749  1.208843 -0.080952 -0.264610
```
### Grouping
Splitting the data into groups based on some criteria
Applying a function to each group independently
Combining the results into a data structure
```
    df = pd.DataFrame({'A' : ['foo', 'bar', 'foo', 'bar',
     ....:                           'foo', 'bar', 'foo', 'foo'],
     ....:                    'B' : ['one', 'one', 'two', 'three',
     ....:                           'two', 'two', 'one', 'three'],
     ....:                    'C' : np.random.randn(8),
     ....:                    'D' : np.random.randn(8)})
     Out[92]:
          A      B         C         D
     0  foo    one -1.202872 -0.055224
     1  bar    one -1.814470  2.395985
     2  foo    two  1.018601  1.552825
     3  bar  three -0.595447  0.166599
     4  foo    two  1.395433  0.047609
     5  bar    two -0.392670 -0.136473
     6  foo    one  0.007207 -0.561757
     7  foo  three  1.928123 -1.623033

     df.groupby('A').sum()
     Out[93]:
                 C        D
     A                     
     bar -2.802588  2.42611
     foo  3.146492 -0.63958

     df.groupby(['A','B']).sum()
     Out[94]:
                       C         D
     A   B                        
     bar one   -1.814470  2.395985
         three -0.595447  0.166599
         two   -0.392670 -0.136473
     foo one   -1.195665 -0.616981
         three  1.928123 -1.623033
         two    2.414034  1.600434
```
Reshaping
```
    tuples = list(zip(*[['bar', 'bar', 'baz', 'baz',
    ....:                      'foo', 'foo', 'qux', 'qux'],
    ....:                     ['one', 'two', 'one', 'two',
    ....:                      'one', 'two', 'one', 'two']]))

    index = pd.MultiIndex.from_tuples(tuples, names=['first', 'second'])
    df = pd.DataFrame(np.random.randn(8, 2), index=index, columns=['A', 'B'])
    df2 = df[:4]
    Out[99]:
                         A         B
    first second                    
    bar   one     0.029399 -0.542108
          two     0.282696 -0.087302
    baz   one    -1.575170  1.771208
          two     0.816482  1.100230    
```
The stack() method “compresses（压缩）” a level in the DataFrame’s columns.
```
    stacked = df2.stack()
    Out[101]:
    first  second   
    bar    one     A    0.029399
                   B   -0.542108
           two     A    0.282696
                   B   -0.087302
    baz    one     A   -1.575170
                   B    1.771208
           two     A    0.816482
                   B    1.100230
    dtype: float64
```
With a “stacked” DataFrame or Series (having a MultiIndex as the index), the inverse operation of stack() is unstack(), which by default unstacks the last level:
```
    stacked.unstack()
    Out[102]:
                         A         B
    first second                    
    bar   one     0.029399 -0.542108
          two     0.282696 -0.087302
    baz   one    -1.575170  1.771208
          two     0.816482  1.100230

    stacked.unstack(1)
    Out[103]:
    second        one       two
    first                      
    bar   A  0.029399  0.282696
          B -0.542108 -0.087302
    baz   A -1.575170  0.816482
          B  1.771208  1.100230

    stacked.unstack(0)
    Out[104]:
    first          bar       baz
    second                      
    one    A  0.029399 -1.575170
           B -0.542108  1.771208
    two    A  0.282696  0.816482
           B -0.087302  1.100230
```
### Pivot(轴) Tables
```
    df = pd.DataFrame({'A' : ['one', 'one', 'two', 'three'] * 3,
    .....:                    'B' : ['A', 'B', 'C'] * 4,
    .....:                    'C' : ['foo', 'foo', 'foo', 'bar', 'bar','bar'] * 2,
    .....:                    'D' : np.random.randn(12),
    .....:                    'E' : np.random.randn(12)})
    Out[106]: df
            A  B    C         D         E
    0     one  A  foo  1.418757 -0.179666
    1     one  B  foo -1.879024  1.291836
    2     two  C  foo  0.536826 -0.009614
    3   three  A  bar  1.006160  0.392149
    4     one  B  bar -0.029716  0.264599
    5     one  C  bar -1.146178 -0.057409
    6     two  A  foo  0.100900 -1.425638
    7   three  B  foo -1.035018  1.024098
    8     one  C  foo  0.314665 -0.106062
    9     one  A  bar -0.773723  1.824375
    10    two  B  bar -1.170653  0.595974
    11  three  C  bar  0.648740  1.167115


    pd.pivot_table(df, values='D', index=['A', 'B'], columns=['C'])
    Out[107]:
    C             bar       foo
    A     B                    
    one   A -0.773723  1.418757
          B -0.029716 -1.879024
          C -1.146178  0.314665
    three A  1.006160       NaN
          B       NaN -1.035018
          C  0.648740       NaN
    two   A       NaN  0.100900
          B -1.170653       NaN
          C       NaN  0.536826
```
### TimeSeries
```
    rng = pd.date_range('1/1/2012', periods=100, freq='S')
    ts = pd.Series(np.random.randint(0, 500, len(rng)), index=rng)
    ts.resample('5Min').sum()
    Out[110]:
    2012-01-01    25083
    Freq: 5T, dtype: int64

    rng = pd.date_range('3/6/2012 00:00', periods=5, freq='D')
    ts = pd.Series(np.random.randn(len(rng)), rng)
    Out[113]:ts
    2012-03-06    0.464000
    2012-03-07    0.227371
    2012-03-08   -0.496922
    2012-03-09    0.306389
    2012-03-10   -2.290613
    Freq: D, dtype: float64

    ts_utc = ts.tz_localize('UTC')  
    Out[115]: ts_utc
    2012-03-06 00:00:00+00:00    0.464000
    2012-03-07 00:00:00+00:00    0.227371
    2012-03-08 00:00:00+00:00   -0.496922
    2012-03-09 00:00:00+00:00    0.306389
    2012-03-10 00:00:00+00:00   -2.290613
    Freq: D, dtype: float64

    ts_utc.tz_convert('US/Eastern')#转换时区
    Out[116]:
    2012-03-05 19:00:00-05:00    0.464000
    2012-03-06 19:00:00-05:00    0.227371
    2012-03-07 19:00:00-05:00   -0.496922
    2012-03-08 19:00:00-05:00    0.306389
    2012-03-09 19:00:00-05:00   -2.290613
    Freq: D, dtype: float64

```
Converting(转变) between time span representations
```
    rng = pd.date_range('1/1/2012', periods=5, freq='M')
    ts = pd.Series(np.random.randn(len(rng)), index=rng)
    Out[119]: ts
    2012-01-31   -1.134623
    2012-02-29   -1.561819
    2012-03-31   -0.260838
    2012-04-30    0.281957
    2012-05-31    1.523962
    Freq: M, dtype: float64

    ps = ts.to_period()
    Out:ps
    2012-01   -1.134623
    2012-02   -1.561819
    2012-03   -0.260838
    2012-04    0.281957
    2012-05    1.523962
    Freq: M, dtype: float64

    ps.to_timestamp()
    Out[122]:
    2012-01-01   -1.134623
    2012-02-01   -1.561819
    2012-03-01   -0.260838
    2012-04-01    0.281957
    2012-05-01    1.523962
    Freq: MS, dtype: float64

```
Converting between period and timestamp enables some convenient arithmetic functions to be used. In the following example, we convert a quarterly frequency with year ending in November to 9am of the end of the month following the quarter end:
```
    prng = pd.period_range('1990Q1', '2000Q4', freq='Q-NOV')
    ts = pd.Series(np.random.randn(len(prng)), prng)
    ts.index = (prng.asfreq('M', 'e') + 1).asfreq('H', 's') + 9
    Out[126]: ts.head()
    1990-03-01 09:00   -0.902937
    1990-06-01 09:00    0.068159
    1990-09-01 09:00   -0.057873
    1990-12-01 09:00   -0.368204
    1991-03-01 09:00   -1.144073
    Freq: H, dtype: float64
```
### Categoricals
```
    df = pd.DataFrame({"id":[1,2,3,4,5,6], "raw_grade":['a', 'b', 'b', 'a', 'a', 'e']})
    df["grade"] = df["raw_grade"].astype("category")
    Out[129]:  df["grade"]
    0    a
    1    b
    2    b
    3    a
    4    a
    5    e
    Name: grade, dtype: category
    Categories (3, object): [a, b, e]    
```
Rename the categories to more meaningful names (assigning to Series.cat.categories is inplace!)
```
    df["grade"].cat.categories = ["very good", "good", "very bad"]

    df["grade"] = df["grade"].cat.set_categories(["very bad", "bad", "medium", "good", "very good"])
    Out[132]: df["grade"]
    0    very good
    1         good
    2         good
    3    very good
    4    very good
    5     very bad
    Name: grade, dtype: category
    Categories (5, object): [very bad, bad, medium, good, very good]
```
Sorting is per order in the categories, not lexical order.
```
    df.sort_values(by="grade")
    Out[133]:
       id raw_grade      grade
    5   6         e   very bad
    1   2         b       good
    2   3         b       good
    0   1         a  very good
    3   4         a  very good
    4   5         a  very good
```
Grouping by a categorical column shows also empty categories
```
    df.groupby("grade").size()
    Out[134]:
    grade
    very bad     1
    bad          0
    medium       0
    good         2
    very good    3
    dtype: int64
```
Plotting
```
    ts = pd.Series(np.random.randn(1000), index=pd.date_range('1/1/2000', periods=1000))
    ...
    ...
```
### Getting Data In/Out
```
    df.to_csv('foo.csv')
    pd.read_csv('foo.csv')
    Out[142]:
         Unnamed: 0          A          B         C          D
    0    2000-01-01   0.266457  -0.399641 -0.219582   1.186860
    1    2000-01-02  -1.170732  -0.345873  1.653061  -0.282953
    2    2000-01-03  -1.734933   0.530468  2.060811  -0.515536
    3    2000-01-04  -1.555121   1.452620  0.239859  -1.156896
    4    2000-01-05   0.578117   0.511371  0.103552  -2.428202
    5    2000-01-06   0.478344   0.449933 -0.741620  -1.962409
    6    2000-01-07   1.235339  -0.091757 -1.543861  -1.084753
    ..          ...        ...        ...       ...        ...
    993  2002-09-20 -10.628548  -9.153563 -7.883146  28.313940
    994  2002-09-21 -10.390377  -8.727491 -6.399645  30.914107
    995  2002-09-22  -8.985362  -8.485624 -4.669462  31.367740
    996  2002-09-23  -9.558560  -8.781216 -4.499815  30.518439
    997  2002-09-24  -9.902058  -9.340490 -4.386639  30.105593
    998  2002-09-25 -10.216020  -9.480682 -3.933802  29.758560
    999  2002-09-26 -11.856774 -10.671012 -3.216025  29.369368
```
HDF5
```
    df.to_hdf('foo.h5','df')
    pd.read_hdf('foo.h5','df')
    Out[144]:
                        A          B         C          D
    2000-01-01   0.266457  -0.399641 -0.219582   1.186860
    2000-01-02  -1.170732  -0.345873  1.653061  -0.282953
    2000-01-03  -1.734933   0.530468  2.060811  -0.515536
    2000-01-04  -1.555121   1.452620  0.239859  -1.156896
    2000-01-05   0.578117   0.511371  0.103552  -2.428202
    2000-01-06   0.478344   0.449933 -0.741620  -1.962409
    2000-01-07   1.235339  -0.091757 -1.543861  -1.084753
    ...               ...        ...       ...        ...
    2002-09-20 -10.628548  -9.153563 -7.883146  28.313940
    2002-09-21 -10.390377  -8.727491 -6.399645  30.914107
    2002-09-22  -8.985362  -8.485624 -4.669462  31.367740
    2002-09-23  -9.558560  -8.781216 -4.499815  30.518439
    2002-09-24  -9.902058  -9.340490 -4.386639  30.105593
    2002-09-25 -10.216020  -9.480682 -3.933802  29.758560
    2002-09-26 -11.856774 -10.671012 -3.216025  29.369368
    [1000 rows x 4 columns]
```
excel
```
     df.to_excel('foo.xlsx', sheet_name='Sheet1')
     pd.read_excel('foo.xlsx', 'Sheet1', index_col=None, na_values=['NA'])
     Out[146]:
                         A          B         C          D
     2000-01-01   0.266457  -0.399641 -0.219582   1.186860
     2000-01-02  -1.170732  -0.345873  1.653061  -0.282953
     2000-01-03  -1.734933   0.530468  2.060811  -0.515536
     2000-01-04  -1.555121   1.452620  0.239859  -1.156896
     2000-01-05   0.578117   0.511371  0.103552  -2.428202
     2000-01-06   0.478344   0.449933 -0.741620  -1.962409
     2000-01-07   1.235339  -0.091757 -1.543861  -1.084753
     ...               ...        ...       ...        ...
     2002-09-20 -10.628548  -9.153563 -7.883146  28.313940
     2002-09-21 -10.390377  -8.727491 -6.399645  30.914107
     2002-09-22  -8.985362  -8.485624 -4.669462  31.367740
     2002-09-23  -9.558560  -8.781216 -4.499815  30.518439
     2002-09-24  -9.902058  -9.340490 -4.386639  30.105593
     2002-09-25 -10.216020  -9.480682 -3.933802  29.758560
     2002-09-26 -11.856774 -10.671012 -3.216025  29.369368

     [1000 rows x 4 columns]
```
